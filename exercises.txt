1. 
For our catlock.c solution, we have the cats reside in a loop that causes their thread to yield and perform no actions if the number of cats eating is 2. In order to avoid starvation, we also added that the cats should wait if the number of mice waiting to eat is 2 or greater (since when the first mouse finishes it increments the number of mice waiting, then the second mouse will reset the count to 0) in this way, the mice are allowed to eat as soon as they are both prepared.

For our catsem.c solution, we initialize a semaphore named mouse_sem to 0 and increment its count by 1 each time mousesem() is called. In this way, we will know when both mice are prepared to eat. Once this scenario occurs, the catsem() solution has a check that occurs after the cat has eaten that increments a semaphore named bothFree_sem when both bowls are freed up for the first time during execution. Afterwards, if it is determined that both the number of mice waiting is 2 and the bothFree_sem has been incremented (as well as both dishes still being free), then another semaphore named miceIn_sem is signaled to alert the mice that they have favorable eating conditions. In this way, the first time that both mice are prepared to eat, the cats work to clear the dishes then allow them to finish before continuing themselves.

2. Because a semaphore can easily be implemented to function the same way as a lock, the semaphore implementation was much simpler as it supplied extra functionality in the form of applications that made use of the semaphore's counter, while maintaining the same benefits of a lock. This is because a semaphore initialized with a count of zero has the same functionality as a lock if executed properly.
